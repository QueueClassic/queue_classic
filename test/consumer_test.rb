require 'helper'

context 'Consumer' do
  setup do
    setup_db
    @session  = QueueClassic::Session.new( database_url )
    @consumer = @session.consumer_for( 'foo' )
    @producer = @session.producer_for( 'foo' )
  end

  teardown do
    @session.close
    teardown_db
  end

  test "consumers have a unique identifier generated by the database" do
    assert_match /consumer-(\d+)/, @consumer.consumer_id
  end

  test 'consumer can reserve an item on the queue' do
    assert_equal 0, @producer.queue.size
    msg = @producer.put( "a message" )
    assert_equal 1, @consumer.queue.size
    assert_equal 0, @consumer.queue.reserved_size
    assert_equal 1, @consumer.queue.ready_size

    item = @consumer.reserve
    assert_equal 0, @consumer.queue.ready_size
    assert_equal 1, @consumer.queue.reserved_size

    assert_equal @consumer.consumer_id, item.reserved_by
  end

  test 'consumer can finalize an item on the queue' do
    @producer.put( "a message")
    msg = @consumer.reserve

    assert_equal 0, @consumer.queue.ready_size
    assert_equal 1, @consumer.queue.reserved_size

    finalized_msg = @consumer.finalize( msg, "all is well" )
    assert finalized_msg.finalized?
    assert_equal 'all is well', finalized_msg.finalized_note
    assert_equal 0, @consumer.queue.ready_size
    assert_equal 0, @consumer.queue.reserved_size
    assert_equal 1, @consumer.queue.finalized_size
  end

  test "an error is raised if an attempt is made to finalize a non-reserved message" do
    assert_equal 0, @producer.queue.size
    msg = @producer.put( "a message")
    assert_raises PGError do
      @consumer.finalize( msg, 'this should not happen' )
    end
  end

  test "A consumer has a different database connection than the session" do
    refute_equal @session.connection, @consumer.connection
  end

  test "can iterate over all the existing messages in its queue, automatically finalizing them" do
    10.times do |x|
      @producer.put( "a message #{x}" )
    end

    count = 0
    assert_equal 0, @consumer.queue.finalized_size
    @consumer.each_message do |msg|
      assert_match /a message \d+/, msg.payload
      count += 1
    end
    assert_equal 10, count
    assert_equal 10, @consumer.queue.finalized_size
  end

  test "#reserve returns nil if there is no message" do
    msg = @consumer.reserve
    assert_nil msg
  end

  test "#reserve returns nil if there is no message after the waiting period" do
    msg = @consumer.reserve( :wait, 0.1 )
    assert_nil msg
  end

  test "#reserve can block until there is a message" do
    t = Thread.new do
      msg = @consumer.reserve( :wait, 1 )
      Thread.current[:msg] = msg
      @consumer.finalize( msg, 'finalized' )
    end

    pmsg = @producer.put("a message")
    t.join
    assert_equal 1, @producer.queue.finalized_size
    assert_equal pmsg.payload, t[:msg].payload
  end
end
